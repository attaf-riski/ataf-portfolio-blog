[{"content":"🔗 Github 🟡 Link Aktif 📜 Dokumentasi API 📚 Bookshelf API Submission Bookshelf API - Kelas Belajar Membuat Aplikasi Back-End untuk Pemula\n🗒️ Sertifikat Kompetensi Kelas Belajar Membuat Aplikasi Back-End untuk Pemula.pdf 1\n🚀 Deskripsi Kelas Belajar Membuat Aplikasi Back-End untuk Pemula Disusun oleh: Dicoding Indonesia Level: Pemula\nKelas ini ditujukan untuk individu yang ingin melangkah menjadi seorang Back-End Developer dengan standar kompetensi internasional milik AWS. Di akhir kelas, siswa dapat membuat RESTful API sederhana secara mandiri untuk mendukung fungsionalitas suatu aplikasi.\nMateri yang dipelajari:\nPengenalan ke Back-End : Menjelaskan peran front-end dan back-end, bagaimana cara client dan server berkomunikasi melalui protokol HTTP, dan arsitektur RESTFul API dalam membangun web service. (3 Jam) Dasar-Dasar Node.js : Mengenal Node.js serta mengetahui dasar dari Node.js seperti global dan process object, modularization, Node Package Manager (NPM), eventing, filesystem, dan teknik stream. (8 Jam) Membangun Web Service menggunakan Node.js : Membangun Web Service menggunakan Node.js secara native dan melalui framework Hapi, membangun RESTFul API sederhana. (10 Jam) Deploy Web Service : Mengenal dan menggunakan Amazon EC2, mengoperasikan Amazon EC2 melalui SSH, menjalankan RESTFul API di Amazon EC2. (5 Jam) Mengonsumsi dan Menguji RESTful API menggunakan Postman : Memasang Postman. Mengonsumsi RESTful API untuk tujuan pengujian dan menuliskan skenario uji otomatis menggunakan Postman. (5 Jam) Evaluasi pembelajaran:\nSubmission : Proyek akhir berupa praktik siswa berbentuk Bookshelf API berupa membuat Back-End dari aplikasi catatan yang memiliki fungsi Create, Read, Update, dan Delete. Total jam yang dibutuhkan untuk menyelesaikan kelas ini, mulai dari persiapan kelas sampai evaluasi belajar, adalah 45 jam.\nShow Credential\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"/projects/bookshelf-api/","summary":"🔗 Github 🟡 Link Aktif 📜 Dokumentasi API 📚 Bookshelf API Submission Bookshelf API - Kelas Belajar Membuat Aplikasi Back-End untuk Pemula\n🗒️ Sertifikat Kompetensi Kelas Belajar Membuat Aplikasi Back-End untuk Pemula.pdf 1\n🚀 Deskripsi Kelas Belajar Membuat Aplikasi Back-End untuk Pemula Disusun oleh: Dicoding Indonesia Level: Pemula\nKelas ini ditujukan untuk individu yang ingin melangkah menjadi seorang Back-End Developer dengan standar kompetensi internasional milik AWS. Di akhir kelas, siswa dapat membuat RESTful API sederhana secara mandiri untuk mendukung fungsionalitas suatu aplikasi.","title":"Bookshelf Api"},{"content":"🔗 Github 🟡 Link Aktif 📚 Bookshelf Apps Submission Aplikasi Pengelolaan Data Menggunakan DOM dan Web Storage - Kelas Belajar Membuat Front-End Web untuk Pemula\n🗒️ Sertifikat Kompetensi Kelas Belajar Membuat Front-End Web untuk Pemula.pdf 1\n🚀 Deskripsi Kelas Belajar Membuat Front-End Web untuk Pemula Disusun oleh: Dicoding Indonesia Level: Pemula\nKelas ini ditujukan untuk seorang Front-End Web Developer yang ingin mengembangkan website yang memiliki fungsionalitas lebih daripada hanya media informasi saja, sesuai dengan standar industri. Di akhir kelas, siswa dapat membuat aplikasi front-end web yang interaktif serta memiliki fitur penyimpanan menggunakan web storage.\nMateri yang dipelajari:\nBrowser Object Model dan Document Object Model : Mempelajari penerapan BOM dan DOM pada halaman website. Selain itu, modul ini mengajarkan teknik pemanipulasian DOM menggunakan JavaScript. (7 jam 55 menit) Interaktif dengan Event : Mempelajari penerapan event dalam menciptakan interaktifitas pada HTML element. (10 jam 45 menit) Penyimpanan Data dengan Web Storage : Mempelajari API browser yang berguna untuk penyimpanan data melalui Web Storage. Dalam modul ini mengajarkan mengenai tipe-tipe storage beserta penerapannya. (8 jam 25 menit) Evaluasi Pembelajaran:\nSubmission (proyek akhir) membuat sebuah website yang menerapkan teknik manipulasi DOM dan web storage Total jam yang dibutuhkan untuk menyelesaikan kelas ini, mulai dari persiapan kelas sampai evaluasi belajar, adalah 45 jam.\nShow Credential\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"/projects/bookshelf-vanilla/","summary":"🔗 Github 🟡 Link Aktif 📚 Bookshelf Apps Submission Aplikasi Pengelolaan Data Menggunakan DOM dan Web Storage - Kelas Belajar Membuat Front-End Web untuk Pemula\n🗒️ Sertifikat Kompetensi Kelas Belajar Membuat Front-End Web untuk Pemula.pdf 1\n🚀 Deskripsi Kelas Belajar Membuat Front-End Web untuk Pemula Disusun oleh: Dicoding Indonesia Level: Pemula\nKelas ini ditujukan untuk seorang Front-End Web Developer yang ingin mengembangkan website yang memiliki fungsionalitas lebih daripada hanya media informasi saja, sesuai dengan standar industri.","title":"Bookshelf Vanilla"},{"content":"Pendahuluan Di dunia ini permasalahan punya lebih dari satu solusi, malahan kadang masalah tidak punya solusi. Solusi yang didapatkan ada yang lebih baik dari solusi lain. Tidak jauh berbeda dengan permasalahan di dunia pemrograman, terdapat banyak solusi yang bisa digunakan untuk menyelesaikan masalah, salah satu masalah yang punya banyak solusi adalah permasalahan Knapsack 🎒.\nPermasalahan Hidup selalu diwarnai dengan permasalahan. Begitu juga dengan knapsack problem yang memiliki banyak masalah turunan yang mirip dengan knapsack. Misalnya saja kasus ini:\nMedia Advertising Corp (MAC) adalah perusahaan yang bergerak di bidang periklanan, khususnya di area Kota Semarang. Untuk meningkatkan pengalaman pengguna di divisi billboard, perusahaan MAC ingin menambahkan fitur agar pengguna bisa memilih billboard dengan anggaran yang pengguna miliki dan mendapatkan pemirsa perhari tertinggi. Bantulah MAC untuk mewujudkan fitur ini.\nPermasalahan di atas adalah masalah knapsack, terlihat dari adanya target untuk mendapatkan pemirsa tertinggi dari satu atau lebih billboard sesuai dengan anggaran iklan pengguna. Misalkan saja tiap billboard memiliki jumlah pemirsa dan harga maka lengkap sudah knapsack komponennya 🎊.\nSelanjutnya terjemahkan permasalahan tersebut ke dalam dunia pemrograman, misalkan saja ditentukan inputan, constraint, dan output agar mirip dengan tantangan di HackerRank.\nInput N = Anggaran Untuk Iklan\nArray Pasangan = Harga Billboard(W) dan Jumlah Pemirsa Perhari(P)\n5000000 \u0026lt;= N \u0026lt;= 100000000 100000 \u0026lt;= elemen W \u0026lt;= 3000000 5000000 \u0026lt;= elemen P \u0026lt;= 30000000 Constraint\n1000 ms Output\njumlah akumulasi pemirsa index billboard terpilih (index mulai dari 1 \u0026amp; urutan dari yang paling besar) Contoh TestCase Mau coba langsung 🤨 sebelum lihat solusi dibawah? Bisa kunjungi kontes HackerRank\nSolusi Karena sudah terindikasi bahwa permasalahan ini adalah tipe knapsack problem maka ada beberapa algoritma yang bisa dipakai untuk menyelesaikannnya seperti Dynamic Programming, Greedy, Exhaustive Search, dan algoritma-algoritma di luar sana yang belum kesebut. Oleh karena itu di sini aku akan memakai Dynamic Programming dan Exhaustive Search.\nMapping permasalahan knapsack:\nAnggaran Iklan = Kapasitas Harga Papan Iklan/billboard = bobot Jumlah Pemirsa = profit Knapsack dengan Dynamic Programming // Nama file: DP.java // Deskripsi: Dynamic Programming Algorithm for Knapsack // Pembuat: Attaf Riski Putra Ramadhan // Last Updated: 11 Juni 2023 import java.util.ArrayList; import java.util.Arrays; import java.util.Scanner; public class DP { static ArrayList\u0026lt;Long\u0026gt; jumlahPemirsa = new ArrayList\u0026lt;\u0026gt;(); static ArrayList\u0026lt;Long\u0026gt; hargaBillboard = new ArrayList\u0026lt;\u0026gt;(); static long pembagi = 1000000; // pembagi nilai besar agar lebih kecil dalam pembuatan tabel dynamic public static void main(String[] args) throws Exception { // KAMUS Long anggaranBiaya; // ALGORITMA try (Scanner input = new Scanner(System.in)) { anggaranBiaya = input.nextLong(); while (input.hasNextBigInteger()) { hargaBillboard.add(input.nextLong()); jumlahPemirsa.add(input.nextLong()); } } DPKnapsack(anggaranBiaya); } static void showTable(int i, int j, long tabel[][]) { for (int k = 0; k \u0026lt; i; k++) { // sampe ke i karena for (int l = 0; l \u0026lt;= j; l++) { // sampe ke = j karena index ditambah satu untuk kolom ke 0 System.out.print(tabel[k][l] + \u0026#34; \u0026#34;); } System.out.println(\u0026#34;===\u0026#34;); } } static long max(long a, long b) { return (a \u0026gt; b) ? a : b; } static void DPKnapsack(Long anggaranBiaya) { long i = jumlahPemirsa.size(); long j = anggaranBiaya / pembagi; long[][] tabel = new long[(int) i][(int) j + 1]; for (long[] row : tabel) { Arrays.fill(row, 0); } for (int k = 0; k \u0026lt; i; k++) { // sampe ke i karena baris for (int l = 0; l \u0026lt;= j; l++) { // sampe ke = j karena index ditambah satu untuk kolom ke 0, kolom // jika biaya billboard \u0026gt; biaya per kolom if (hargaBillboard.get(k) / pembagi \u0026gt; l) { // berikan nilai sebelumnya if (k == 0) { // karena paling atas tabel[k][l] = 0; } else { tabel[k][l] = tabel[k - 1][l]; } } else if (hargaBillboard.get(k) / pembagi \u0026lt;= l) { // harga kurang dari atau sama dengan if (k == 0) { // karena paling atas // lakukan komparasi tabel[k][l] = jumlahPemirsa.get(k); } else { // lakukan komparasi tabel[k][l] = max( jumlahPemirsa.get(k) + tabel[k - 1][l - (int) (hargaBillboard.get(k) / pembagi)], tabel[k - 1][l]); // ditambah sisa weight dari proses sebelumnya } } } } // untuk menampilkan tabel DP // showTable((int) i, (int) j, tabel); // show product picked long result = tabel[(int) i - 1][(int) j]; System.out.println(result); // // tidak dapat billboard karena uang kurang if (result == 0) { System.out.print(0); return; } // tampilkan billboard mana yang diambil int w = (int) j; for (int k = (int) i; k \u0026gt;= 0; k--) { if (k == 0) { // paling atas sendiri System.out.print(k + 1); } else { if (result == tabel[k - 1][w]) { // tidak termasuk continue; } else { // karena termasuk System.out.printf((k + 1) + \u0026#34; \u0026#34;); result -= jumlahPemirsa.get(k); w -= hargaBillboard.get(k) / pembagi; } // sudah berhenti if (result == 0) { break; } } } } } Knapsack dengan Exhaustive Search // Nama file: BF.java // Deskripsi: Brute Force Algorithm for Knapsack // Pembuat: Attaf Riski Putra Ramadhan // Last Updated: 11 Juni 2023 import java.util.ArrayList; import java.util.Scanner; public class BF { static ArrayList\u0026lt;Long\u0026gt; jumlahPemirsa = new ArrayList\u0026lt;\u0026gt;(); static ArrayList\u0026lt;Long\u0026gt; hargaBillboard = new ArrayList\u0026lt;\u0026gt;(); // untuk BFKnapsack static long maxJumlahPemirsa = 0; static long maxBiaya = 0; static int[] bestSelection; public static void main(String[] args) throws Exception { // KAMUS Long anggaranBiaya; // ALGORITMA try (Scanner input = new Scanner(System.in)) { anggaranBiaya = input.nextLong(); while(input.hasNextBigInteger()){ hargaBillboard.add(input.nextLong()); jumlahPemirsa.add(input.nextLong()); } } // DPKnapsack(anggaranBiaya); int n = hargaBillboard.size(); int[] selection = new int[n]; bestSelection = new int[n]; exhaustiveSearchKnapsack(anggaranBiaya, selection, 0); System.out.println(maxJumlahPemirsa); // item if(maxJumlahPemirsa==0){ System.out.println(0); }else{ for (int i = n-1; i \u0026gt;= 0; i--) { if(bestSelection[i]==1 \u0026amp;\u0026amp; i==0){ System.out.print(i+1); }else if(bestSelection[i]==1){ System.out.print(i+1+\u0026#34; \u0026#34;); } } } } // knapsack brute force private static void exhaustiveSearchKnapsack(long capacity, int[] selection, int currentItem) { int n = hargaBillboard.size(); // sudah mencapai kondisi kombinasi yang tepat if (currentItem == n) { int totalWeight = 0; int totalValue = 0; for (int i = 0; i \u0026lt; n; i++) { totalWeight += hargaBillboard.get(i) * selection[i]; totalValue += jumlahPemirsa.get(i) * selection[i]; } if (totalWeight \u0026lt;= capacity \u0026amp;\u0026amp; totalValue \u0026gt; maxJumlahPemirsa) { maxBiaya = totalWeight; maxJumlahPemirsa = totalValue; System.arraycopy(selection, 0, bestSelection, 0, n); } return; } // Setiap item memiliki dua kemungkinan: dipilih (1) atau tidak dipilih (0) // menyebabkan 2^n selection[currentItem] = 1; exhaustiveSearchKnapsack(capacity, selection, currentItem + 1); selection[currentItem] = 0; exhaustiveSearchKnapsack(capacity, selection, currentItem + 1); } } Perbandingan DP VS ES Sebelum lanjut, coba kita lihat tabel dari Software University Foundation Solusi DP di atas memiliki kompleksitas waktu O(m.n) dimana m adalah jumlah kapasitas dan n adalah jumlah papan iklan yang termasuk kedalam kompleksitas waktu O(nˆ2). Kemudian untuk solusi Exhaustive Search memiliki kompleksitas waktu O(2ˆn) dimana n adalah banyak papan iklan.\nJadi, apabila ada 50 papan iklan maka waktu yang dipakai oleh Exhaustive Search untuk menghasilkan solusi akan lebih dari 1000ms (1s) dan Dynamic Programming akan masih aman.\nItu untuk sekarang! Pepatah mengatakan \u0026ldquo;Ada banyak solusi untuk suatu permasalah, tapi suatu solusi juga dapat mengakibatkan banyak masalah\u0026rdquo; hhh mungkin kurang nyambung pepatahnya, tapi pepatah itu terdengar keren 😂 Seperti biasa jika kamu membaca sampai titik ini aku ucapkan terimakasih untuk waktu yang sudah kamu luangkan. Maaf kalau ada tutur kata aku yang kurang berkenan 😌\nSpecial Tributes Makasih untuk gambarnya\n","permalink":"/blog/knapsack_dp_es/","summary":"Pendahuluan Di dunia ini permasalahan punya lebih dari satu solusi, malahan kadang masalah tidak punya solusi. Solusi yang didapatkan ada yang lebih baik dari solusi lain. Tidak jauh berbeda dengan permasalahan di dunia pemrograman, terdapat banyak solusi yang bisa digunakan untuk menyelesaikan masalah, salah satu masalah yang punya banyak solusi adalah permasalahan Knapsack 🎒.\nPermasalahan Hidup selalu diwarnai dengan permasalahan. Begitu juga dengan knapsack problem yang memiliki banyak masalah turunan yang mirip dengan knapsack.","title":"Knapsack Problem With Dynamic Programming And Exhaustive Search"},{"content":"🔗 GitHub ✏️ Tugas saya di Anforcom adalah membuat landing page untuk acara ini, dengan menggunakan TailwindCSS dan NextJS untuk membuatnya. Anforcom (Annual Informatics Competition) adalah serangkaian acara dan perlombaan yang diadakan Mahasiswa Informatika Universitas Diponegoro. Event ini dilaksanakan dalam rangka mengenalkan Kultur Teknologi kepada masyarakat dan menumbuhkan jiwa-jiwa kompetititf yang sportif di kalangan pelajar 👨🏽‍🎓.\n","permalink":"/projects/anforcom-2022/","summary":"🔗 GitHub ✏️ Tugas saya di Anforcom adalah membuat landing page untuk acara ini, dengan menggunakan TailwindCSS dan NextJS untuk membuatnya. Anforcom (Annual Informatics Competition) adalah serangkaian acara dan perlombaan yang diadakan Mahasiswa Informatika Universitas Diponegoro. Event ini dilaksanakan dalam rangka mengenalkan Kultur Teknologi kepada masyarakat dan menumbuhkan jiwa-jiwa kompetititf yang sportif di kalangan pelajar 👨🏽‍🎓.","title":"Landing Page Anforcom 2022"},{"content":"🔗 Github 🟡 Link Aktif Landing page ini dibuat menggunakan teknologi nextjs dan tailwindCSS. Website ini dibuat bertujuan untuk menjadi halaman yang akan digunakan para pembaca untuk menambah wawasan dari organisasi digit.\n","permalink":"/projects/web-digit-2023/","summary":"🔗 Github 🟡 Link Aktif Landing page ini dibuat menggunakan teknologi nextjs dan tailwindCSS. Website ini dibuat bertujuan untuk menjadi halaman yang akan digunakan para pembaca untuk menambah wawasan dari organisasi digit.","title":"Landing Page Digit 2023"},{"content":"🔗 GitHub LemariRapi adalah aplikasi mobile yang dibuat menggunakan teknologi flutter dan menggunakan database dari firebase. Kegunaan utama dari aplikasi ini yaitu dapat menyimpan data digital pakaian kedalam smartphone android kamu. Aku membuat aplikasi ini ketika liburan semester 2 dan juga untuk menjadi syarat kelulusan kursus flutter dicoding. Slogan aplikasi ini adalah \u0026ldquo;LemariRapi bikin lemari lo jadi rapi\u0026rdquo; 😄\n","permalink":"/projects/lemari-rapi/","summary":"🔗 GitHub LemariRapi adalah aplikasi mobile yang dibuat menggunakan teknologi flutter dan menggunakan database dari firebase. Kegunaan utama dari aplikasi ini yaitu dapat menyimpan data digital pakaian kedalam smartphone android kamu. Aku membuat aplikasi ini ketika liburan semester 2 dan juga untuk menjadi syarat kelulusan kursus flutter dicoding. Slogan aplikasi ini adalah \u0026ldquo;LemariRapi bikin lemari lo jadi rapi\u0026rdquo; 😄","title":"Lemari Rapi"},{"content":"Pendahuluan Pernah terbayang bagaimana password kamu diamankan di dalam server? Atau pernah kepikiran bagaimana pesan whatsapp kamu dikirim secara aman? Enkripsi jawabannya! Enkripsi yang menjadi standar dunia digital saat ini merupakan jenis yang cukup aman dan terbaru. Nah, pada kesempatan ini aku mau berbagi tentang modifikasi enkripsi klasik yang tentunya lebih mudah daripada enkripsi modern yaa, namanya adalah enkripsi vigenere cipher 🔑.\nVigenere Cipher adalah salah satu teknik enkripsi klasik yang diciptakan pada tahun 1553 oleh Blaise de Vigenere, seorang matematikawan Prancis. Selama berabad-abad, teknik ini telah digunakan untuk menyandikan pesan rahasia dan banyak dianggap sebagai salah satu cipher yang paling tidak dapat ditembus. Keren ngga tuh!\nCara Kerja Enkripsi Vigenere Cipher Cara kerjanya adalah tiap huruf pada kalimat yang akan dienkripsi memiliki nilai ascii, nilai tersebut akan ditambah dengan nilai ascii dari kunci lalu di modulus 256. Tunggu kenapa di modulus? Hal tersebut karena kali ini aku akan memakai kode ascii yang jumlah hurufnya 256 kalau lebih dari itu ngga di hitung dulu hurufnya.\nEnkripsi Dekripsi Untuk mendekripsi atau mengubah dari pesan enkripsi ke pesan asli caranya dengan mengurangi nilai ascii tiap huruf enkripsi dengan nilai kunci lalu di modulus 256.\nKali ini aku pakai bahasa pemrograman python untuk mengimplementasikan algoritma dari enkripsi vigenere cipher. Biasanya kalau lihat kodenya atau lihat praktiknya bakalan lebih mudah ya,\nEnkripsi # Fungsi Enkripsi def cipherText(message, key_new): # Kamus lokal cipher_text = \u0026#39;\u0026#39; i = 0 # Algoritma for letter in message: x = ord(letter)+(ord(key_new[i])) % 256 cipher_text += chr(x) i += 1 return cipher_text Dekripsi # Fungsi Dekripsi def originalText(cipher_text, key_new): # Kamus lokal or_txt = \u0026#39;\u0026#39; i = 0 # Algoritma for letter in cipher_text: x = ord(letter)-(ord(key_new[i])+256) % 256 or_txt += chr(x) i += 1 return or_txt Menghasilkan Kunci Kunci dalam vigenere cipher adalah kunci, lohe kok aneh. hhh. Tapi memang benar kunci dalam algoritma enkripsi ini sangat penting. Lebih baik terlihat pesannya daripada terlihat kuncinya. Kunci dimasukan oleh pemrograman yang kemudian akan disesuaikan panjangnya dengan pesan asli agar semua huruf tercakup.\n# Membuat kunci baru def generate_key(message, key): # Kamus Lokal i = 0 # Algoritma while True: if len(key) == len(message): break else: key += (key[i% len(key)]) i += 1 print(\u0026#34;key: \u0026#34;,key) return key Kenapa Perlu Memofifikasi Vigenere Cipher? Pertanyaan bagus, masalah yang akan muncul ketika menggunakan enkripsi vigenere cipher adalah pesan cipher dapat memiliki pola kalau pesannya memiliki huruf yang sama dan itu adalah hal yang tidak bagus. Modifikasi Enkripsi Vigenere Cipher Berangkat dari kekurangan vigenere cipher aku bakal modif ini algoritma, konsepnya nanti membagi nilai suatu huruf dipesan menjadi dua bagian yang apabila dijumlahkan akan menghasilkan nilai asli itu sendiri. Lalu nilainya dapat dari mana? Dengan cara menghasilkannya secara random antara 0 - nilai asli. Lalu nilai asli dikurangi nilai random tersebut sehingga dapat menghasilkan pesan yang lebih panjang dua kali.\nEnkripsi # buat original text 2X lipat lebih panjang for letter in message: z = ord(letter) nil_random = random.randint(1, z) modif_ori += chr(nil_random) modif_ori += chr(z-nil_random) Baru setelah itu dienkripsi seperti biasa seperti vigenere cipher, namun tentunya dengan modifikasi sedikit agar satu kunci bisa untuk dua huruf\nDekripsi Untuk dekripsinya, prosesnya dibalik dari proses enkripsi. Memakai satu kunci untuk dua huruf cipher text baru setelah itu digabung.\n# Fungsi Dekripsi def originalText(cipher_text, key_new): # Kamus lokal or_txt = \u0026#39;\u0026#39; i = 0 modif_ori = \u0026#39;\u0026#39;; # Algoritma # deksripsi seperti biasa for j in range(1,len(cipher_text),2): #pakai satu kunci untuk 2 original text for k in range(2): x = (ord(cipher_text[j+k-1])-(ord(key_new[i])+256)) % 256 or_txt += chr(x) i += 1 # jadikan or_txt 2 kali lebih kecil for r in range(0,len(or_txt),2): modif_ori += chr(ord(or_txt[r])+ord(or_txt[r+1])) return modif_ori Untuk proses menghasilkan kunci sama saja\nKelebihan Dengan menggunakan algoritma ini, pesan cipher tidak akan memiliki pola dan akan random setiap dihasilkan!\nVigenere Cipher Asli Python # Nama file: vigenere-cipher.ipynb # Deskripsi: modul vigenere-cipher tanpa autokey # Pembuat: Attaf Riski # Tanggal: 9 Des 2022 import random # Membuat kunci baru def generate_key(message, key): # Kamus Lokal i = 0 # Algoritma while True: if len(key) == len(message): break else: key += (key[i% len(key)]) i += 1 print(\u0026#34;key: \u0026#34;,key) return key # Fungsi Enkripsi def cipherText(message, key_new): # Kamus lokal cipher_text = \u0026#39;\u0026#39; i = 0 # Algoritma for letter in message: x = ord(letter)+(ord(key_new[i])) % 256 cipher_text += chr(x) i += 1 return cipher_text # Fungsi Dekripsi def originalText(cipher_text, key_new): # Kamus lokal or_txt = \u0026#39;\u0026#39; i = 0 # Algoritma for letter in cipher_text: x = ord(letter)-(ord(key_new[i])+256) % 256 or_txt += chr(x) i += 1 return or_txt def main(): message = \u0026#39;aaaaaaaaaaaaaaaaa\u0026#39; key = \u0026#39;februari\u0026#39; key_new = \u0026#39;\u0026#39; if(len(key)\u0026gt;len(message)): key_new = key[:len(message)] elif(len(key)\u0026lt;len(message)): key_new = generate_key(message, key) else: key_new = key cipher_text = cipherText(message, key_new) original_text = originalText(cipher_text, key_new) print(\u0026#34;Teks Cipher =\u0026#34;, cipher_text) print(\u0026#34;Teks Asli =\u0026#34;, original_text) # Executes the main function if __name__ == \u0026#39;__main__\u0026#39;: main() Vigenere Cipher Modifikasi # Nama file: modifikasi-vigenere-cipher.ipynb # Deskripsi: tugas akhir KJI \u0026gt; modul modifikasi vigenere cipher # Pembuat: Attaf Riski # Tanggal: 8 Des 2022 import random # Membuat kunci baru def generate_key(message, key): # Kamus Lokal i = 0 # Algoritma while True: if len(key) == len(message): break else: key += key[i % len(key)] i += 1 print(\u0026#34;key: \u0026#34;,key) return key # Fungsi Enkripsi def cipherText(message, key_new): # Kamus lokal cipher_text = \u0026#39;\u0026#39; i = 0 nil_random = 0; modif_ori = \u0026#39;\u0026#39; # Algoritma # buat original text 2X lipat lebih panjang for letter in message: z = ord(letter) nil_random = random.randint(1, z) modif_ori += chr(nil_random) modif_ori += chr(z-nil_random) # enkripsi seperti biasa for j in range(1,len(modif_ori),2): #pakai satu kunci untuk 2 original text for k in range(2): x = (ord(modif_ori[j+k-1])+(ord(key_new[i]))) % 256 cipher_text += chr(x) i += 1 return cipher_text # Fungsi Dekripsi def originalText(cipher_text, key_new): # Kamus lokal or_txt = \u0026#39;\u0026#39; i = 0 modif_ori = \u0026#39;\u0026#39;; # Algoritma # deksripsi seperti biasa for j in range(1,len(cipher_text),2): #pakai satu kunci untuk 2 original text for k in range(2): x = (ord(cipher_text[j+k-1])-(ord(key_new[i])+256)) % 256 or_txt += chr(x) i += 1 # jadikan or_txt 2 kali lebih kecil for r in range(0,len(or_txt),2): modif_ori += chr(ord(or_txt[r])+ord(or_txt[r+1])) return modif_ori def main(): message = \u0026#39;aaaaaaaaaaaaaaaaa\u0026#39; key = \u0026#39;februari\u0026#39; key_new = \u0026#39;\u0026#39; if(len(key)\u0026gt;len(message)): key_new = key[:len(message)] elif(len(key)\u0026lt;len(message)): key_new = generate_key(message, key) else: key_new = key cipher_text = cipherText(message, key_new) original_text = originalText(cipher_text, key_new) print(\u0026#34;Teks Cipher =\u0026#34;, cipher_text) print(\u0026#34;Teks Asli =\u0026#34;, original_text) # Executes the main function if __name__ == \u0026#39;__main__\u0026#39;: main() Itu Sudah Semua! Kalau mau lihat colab. Jika kamu membaca sampai titik ini aku ucapkan terimakasih, dengan ini juga kamu telah mempelajari salah satu jenis enkripsi klasik, kalau kamu tertarik coba deh cari keyword ini di google: autokey dan enkripsi modern. Maaf kalau ada tutur kata yang kurang berkenan 😌. Thanks Chat GPT for the layout ❤️.\n","permalink":"/blog/modifikasi_vigenere_cipher/","summary":"Pendahuluan Pernah terbayang bagaimana password kamu diamankan di dalam server? Atau pernah kepikiran bagaimana pesan whatsapp kamu dikirim secara aman? Enkripsi jawabannya! Enkripsi yang menjadi standar dunia digital saat ini merupakan jenis yang cukup aman dan terbaru. Nah, pada kesempatan ini aku mau berbagi tentang modifikasi enkripsi klasik yang tentunya lebih mudah daripada enkripsi modern yaa, namanya adalah enkripsi vigenere cipher 🔑.\nVigenere Cipher adalah salah satu teknik enkripsi klasik yang diciptakan pada tahun 1553 oleh Blaise de Vigenere, seorang matematikawan Prancis.","title":"Modifikasi Enkripsi Vigenere Cipher"},{"content":"🔗 Github pos_lks_2020_tingkat_kabupaten Ini adalah projek yang saya kerjakan ketika lomba kompetensi siswa (LKS) 2020 tingkat kabupaten semarang. Waktu pengerjaan 9 jam.\nPembukaan Ini adalah projek yang saya kerjakan untuk lomba kompetensi siswa tingkat kabupaten semarang tahun 2020 dan alhamdulillah dapat juara 1 dan akan mewakili provinsi kab semarang di tingkat provinsi jawa tengah\nCara Menggunakan Cara menggunakan projek ini ada di file baca saya\n","permalink":"/projects/pos-lks20/","summary":"🔗 Github pos_lks_2020_tingkat_kabupaten Ini adalah projek yang saya kerjakan ketika lomba kompetensi siswa (LKS) 2020 tingkat kabupaten semarang. Waktu pengerjaan 9 jam.\nPembukaan Ini adalah projek yang saya kerjakan untuk lomba kompetensi siswa tingkat kabupaten semarang tahun 2020 dan alhamdulillah dapat juara 1 dan akan mewakili provinsi kab semarang di tingkat provinsi jawa tengah\nCara Menggunakan Cara menggunakan projek ini ada di file baca saya","title":"POS LKS 2020"},{"content":"🟡 Link Aktif Pada website ini saya bertugas untuk melakukan migrasi hosting dan migrasi domain pada tahun November 2022. Website ini dibangun menggunakan wordpress dan plugin UI yang digunakan adalah Elementor.\n","permalink":"/projects/web-addawaa/","summary":"🟡 Link Aktif Pada website ini saya bertugas untuk melakukan migrasi hosting dan migrasi domain pada tahun November 2022. Website ini dibangun menggunakan wordpress dan plugin UI yang digunakan adalah Elementor.","title":"Wordpress Addawaa 2022"}]